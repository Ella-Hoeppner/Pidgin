use crate::{GeneralizedBlock, GeneralizedValue, Instruction, Value};

pub type SSARegister = usize;

use Instruction::*;

pub type SSAInstruction = Instruction<SSARegister, (SSARegister, SSARegister)>;
pub type SSABlock<M> =
  GeneralizedBlock<SSARegister, (SSARegister, SSARegister), M>;
pub type SSAValue<M> =
  GeneralizedValue<SSARegister, (SSARegister, SSARegister), M>;

impl SSAInstruction {
  pub fn input_and_output_registers(
    &self,
  ) -> (Vec<SSARegister>, Vec<SSARegister>) {
    let (x, y) = match self {
      DebugPrint(_) => (vec![], vec![]),
      Clear(to) => (vec![], vec![to]),
      Copy(to, from) => (vec![from], vec![to]),
      Const(to, _) => (vec![], vec![to]),
      Print(from) => (vec![from], vec![]),
      Return(from) => (vec![from], vec![]),
      CopyArgument(from) => (vec![from], vec![]),
      StealArgument(from) => (vec![from], vec![]),
      Call(to, from, _) => (vec![from], vec![to]),
      Apply((from, to), f) => (vec![from, f], vec![to]),
      CallSelf(to, _) => (vec![], vec![to]),
      ApplySelf((from, to)) => (vec![from], vec![to]),
      CallAndReturn(f, _) => (vec![f], vec![]),
      ApplyAndReturn(from, _) => (vec![from], vec![]),
      CallSelfAndReturn(_) => (vec![], vec![]),
      ApplySelfAndReturn(from) => (vec![from], vec![]),
      CallingFunction(to) => (vec![], vec![to]),
      Jump(_) => (vec![], vec![]),
      Lookup(to, _) => (vec![], vec![to]),
      If(from) => (vec![from], vec![]),
      Else => (vec![], vec![]),
      ElseIf(from) => (vec![from], vec![]),
      EndIf => (vec![], vec![]),
      Partial(to, f, arg) => (vec![f, arg], vec![to]),
      Compose(to, f_1, f_2) => (vec![f_1, f_2], vec![to]),
      FindSome(to, f, collection) => (vec![f, collection], vec![to]),
      ReduceWithoutInitialValue((from, to), f) => (vec![from, f], vec![to]),
      ReduceWithInitialValue((from, to), f, initial) => {
        (vec![from, f, initial], vec![to])
      }
      Memoize(to, from) => (vec![from], vec![to]),
      Constantly(to, from) => (vec![from], vec![to]),
      NumericalEqual(to, a, b) => (vec![a, b], vec![to]),
      IsZero(to, from) => (vec![from], vec![to]),
      IsNan(to, from) => (vec![from], vec![to]),
      IsInf(to, from) => (vec![from], vec![to]),
      IsEven(to, from) => (vec![from], vec![to]),
      IsOdd(to, from) => (vec![from], vec![to]),
      IsPos(to, from) => (vec![from], vec![to]),
      IsNeg(to, from) => (vec![from], vec![to]),
      Inc(to, from) => (vec![from], vec![to]),
      Dec(to, from) => (vec![from], vec![to]),
      Negate(to, from) => (vec![from], vec![to]),
      Abs(to, from) => (vec![from], vec![to]),
      Floor(to, from) => (vec![from], vec![to]),
      Ceil(to, from) => (vec![from], vec![to]),
      Sqrt(to, from) => (vec![from], vec![to]),
      Exp(to, from) => (vec![from], vec![to]),
      Exp2(to, from) => (vec![from], vec![to]),
      Ln(to, from) => (vec![from], vec![to]),
      Log2(to, from) => (vec![from], vec![to]),
      Add(to, a, b) => (vec![a, b], vec![to]),
      Subtract(to, a, b) => (vec![a, b], vec![to]),
      Multiply(to, a, b) => (vec![a, b], vec![to]),
      Divide(to, a, b) => (vec![a, b], vec![to]),
      Pow(to, a, b) => (vec![a, b], vec![to]),
      Mod(to, a, b) => (vec![a, b], vec![to]),
      Quot(to, a, b) => (vec![a, b], vec![to]),
      Min(to, a, b) => (vec![a, b], vec![to]),
      Max(to, a, b) => (vec![a, b], vec![to]),
      GreaterThan(to, a, b) => (vec![a, b], vec![to]),
      GreaterThanOrEqual(to, a, b) => (vec![a, b], vec![to]),
      LessThan(to, a, b) => (vec![a, b], vec![to]),
      LessThanOrEqual(to, a, b) => (vec![a, b], vec![to]),
      Rand(to) => (vec![], vec![to]),
      UpperBoundedRand(to, from) => (vec![from], vec![to]),
      LowerUpperBoundedRand(to, a, b) => (vec![a, b], vec![to]),
      RandInt(to, from) => (vec![from], vec![to]),
      LowerBoundedRandInt(to, a, b) => (vec![a, b], vec![to]),
      Equal(to, a, b) => (vec![a, b], vec![to]),
      NotEqual(to, a, b) => (vec![a, b], vec![to]),
      Not(to, from) => (vec![from], vec![to]),
      And(to, a, b) => (vec![a, b], vec![to]),
      Or(to, a, b) => (vec![a, b], vec![to]),
      Xor(to, a, b) => (vec![a, b], vec![to]),
      IsEmpty(to, from) => (vec![from], vec![to]),
      First(to, from) => (vec![from], vec![to]),
      Count(to, from) => (vec![from], vec![to]),
      Flatten(to, from) => (vec![from], vec![to]),
      Remove((from, to), x) => (vec![from, x], vec![to]),
      Filter((from, to), f) => (vec![from, f], vec![to]),
      Map((from, to), f) => (vec![from, f], vec![to]),
      DoubleMap((from, to), a, b) => (vec![from, a, b], vec![to]),
      MultiCollectionMap((from, to), f) => (vec![from, f], vec![to]),
      Set((from, to), a, b) => (vec![from, a, b], vec![to]),
      SetIn((from, to), a, b) => (vec![from, a, b], vec![to]),
      Get(to, a, b) => (vec![a, b], vec![to]),
      GetIn(to, a, b) => (vec![a, b], vec![to]),
      Update((from, to), a, b) => (vec![from, a, b], vec![to]),
      UpdateIn((from, to), a, b) => (vec![from, a, b], vec![to]),
      MinKey(to, a, b) => (vec![a, b], vec![to]),
      MaxKey(to, a, b) => (vec![a, b], vec![to]),
      Push((from, to), f) => (vec![from, f], vec![to]),
      Sort((from, to)) => (vec![from], vec![to]),
      SortBy((from, to), f) => (vec![from, f], vec![to]),
      EmptyList(to) => (vec![], vec![to]),
      Last(to, from) => (vec![from], vec![to]),
      Rest((from, to)) => (vec![from], vec![to]),
      ButLast((from, to)) => (vec![from], vec![to]),
      Nth(to, a, b) => (vec![a, b], vec![to]),
      NthFromLast(to, a, b) => (vec![a, b], vec![to]),
      Cons((from, to), x) => (vec![from, x], vec![to]),
      Concat((from, to), x) => (vec![from, x], vec![to]),
      Take((from, to), x) => (vec![from, x], vec![to]),
      Drop((from, to), x) => (vec![from, x], vec![to]),
      Reverse((from, to)) => (vec![from], vec![to]),
      Distinct((from, to)) => (vec![from], vec![to]),
      Sub((from, to), a, b) => (vec![from, a, b], vec![to]),
      Partition(to, a, b) => (vec![a, b], vec![to]),
      SteppedPartition((from, to), a, b) => (vec![from, a, b], vec![to]),
      Pad((from, to), a, b) => (vec![from, a, b], vec![to]),
      EmptyMap(to) => (vec![], vec![to]),
      Keys(to, from) => (vec![from], vec![to]),
      Values(to, from) => (vec![from], vec![to]),
      Zip(to, a, b) => (vec![a, b], vec![to]),
      Invert((from, to)) => (vec![from], vec![to]),
      Merge(to, a, b) => (vec![a, b], vec![to]),
      MergeWith((from, to), a, b) => (vec![from, a, b], vec![to]),
      MapKeys((from, to), f) => (vec![from, f], vec![to]),
      MapValues((from, to), f) => (vec![from, f], vec![to]),
      SelectKeys((from, to), x) => (vec![from, x], vec![to]),
      EmptySet(to) => (vec![], vec![to]),
      Union(to, a, b) => (vec![a, b], vec![to]),
      Intersection(to, a, b) => (vec![a, b], vec![to]),
      Difference(to, a, b) => (vec![a, b], vec![to]),
      SymmetricDifference(to, a, b) => (vec![a, b], vec![to]),
      InfiniteRange(to) => (vec![], vec![to]),
      UpperBoundedRange(to, from) => (vec![from], vec![to]),
      LowerUpperBoundedRange(to, a, b) => (vec![a, b], vec![to]),
      InfiniteRepeat(to, from) => (vec![from], vec![to]),
      BoundedRepeat(to, a, b) => (vec![a, b], vec![to]),
      InfiniteRepeatedly(to, from) => (vec![from], vec![to]),
      BoundedRepeatedly(to, a, b) => (vec![a, b], vec![to]),
      InfiniteIterate(to, a, b) => (vec![a, b], vec![to]),
      BoundedIterate((from, to), a, b) => (vec![from, a, b], vec![to]),
      CreateCell(to) => (vec![], vec![to]),
      GetCellValue(to, from) => (vec![from], vec![to]),
      SetCellValue(to, from) => (vec![from], vec![to]),
      UpdateCell(to, from) => (vec![from], vec![to]),
      CreateCoroutine((from, to)) => (vec![from], vec![to]),
      IsCoroutineAlive(to, from) => (vec![from], vec![to]),
      Yield(from) => (vec![from], vec![]),
      YieldAndAccept(from, _, _) => (vec![from], vec![]),
      IsNil(to, from) => (vec![from], vec![to]),
      IsBool(to, from) => (vec![from], vec![to]),
      IsChar(to, from) => (vec![from], vec![to]),
      IsNum(to, from) => (vec![from], vec![to]),
      IsInt(to, from) => (vec![from], vec![to]),
      IsFloat(to, from) => (vec![from], vec![to]),
      IsSymbol(to, from) => (vec![from], vec![to]),
      IsString(to, from) => (vec![from], vec![to]),
      IsList(to, from) => (vec![from], vec![to]),
      IsMap(to, from) => (vec![from], vec![to]),
      IsSet(to, from) => (vec![from], vec![to]),
      IsCollection(to, from) => (vec![from], vec![to]),
      IsFn(to, from) => (vec![from], vec![to]),
      IsError(to, from) => (vec![from], vec![to]),
      IsCell(to, from) => (vec![from], vec![to]),
      IsCoroutine(to, from) => (vec![from], vec![to]),
      ToBool(to, from) => (vec![from], vec![to]),
      ToChar(to, from) => (vec![from], vec![to]),
      ToNum(to, from) => (vec![from], vec![to]),
      ToInt(to, from) => (vec![from], vec![to]),
      ToFloat(to, from) => (vec![from], vec![to]),
      ToSymbol(to, from) => (vec![from], vec![to]),
      ToString(to, from) => (vec![from], vec![to]),
      ToList(to, from) => (vec![from], vec![to]),
      ToMap(to, from) => (vec![from], vec![to]),
      ToSet(to, from) => (vec![from], vec![to]),
      ToError(to, from) => (vec![from], vec![to]),
    };
    (
      x.into_iter().cloned().collect(),
      y.into_iter().cloned().collect(),
    )
  }
}
